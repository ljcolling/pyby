use dict_derive::{FromPyObject, IntoPyObject};
use gkquad::single::algorithm::QAGS;
use gkquad::single::Integrator;
use itertools::Itertools;
// use pyo3::impl_::pyfunction::wrap_pyfunction;
use pyo3::prelude::*;
use r_mathlib::cauchy_cdf as pcauchy;
use r_mathlib::cauchy_pdf as dcauchy;
use r_mathlib::non_central_t_pdf;
use r_mathlib::students_t_cdf;
// use rand::distributions::Normal as NormalRand;
// use rand::prelude::*;
// use rand::rngs::SmallRng;
use rayon::prelude::*;
use std::f64::{INFINITY, NEG_INFINITY};

#[derive(FromPyObject, IntoPyObject, Debug)]
struct Prior {
    family: String,
    params: Vec<f64>,
    alternative: String,
}

#[derive(FromPyObject, IntoPyObject, Debug)]
struct SamplingRule {
    n_min: i32,
    n_max: i32,
    step_size: i32,
}

impl SamplingRule {
    fn unpack(&self) -> (i32, i32, i32) {
        (self.n_min, self.n_max, self.step_size)
    }
}

impl Prior {
    fn function(&self) -> Box<impl Fn(f64) -> f64> {
        let (ll, ul) = match self.alternative.as_str() {
            "two.sided" => (None, None),
            "greater" => (Some(0.), None),
            "less" => (None, Some(0.)),
            _ => (Some(0.), Some(0.)),
        };

        cauchy_prior(self.params[0], self.params[1], ll, ul)
    }
}

#[derive(FromPyObject, IntoPyObject, Debug)]
struct Likelihood {
    family: String,
    params: Vec<f64>,
}

fn welfords(
    (group, count, mean, squared_distances, _, _, _, _): &mut (
        usize,
        f64,
        f64,
        f64,
        f64,
        f64,
        f64,
        f64,
    ),
    x: &f64,
) -> Option<(usize, f64, f64, f64, f64, f64, f64, f64)> {
    *count += 1.;
    let delta = x - *mean;
    *mean += delta / *count;
    let delta2 = x - *mean;
    *squared_distances += delta * delta2;
    let sd = (*squared_distances / (*count - 1.)).sqrt();
    let se = sd / count.sqrt();
    let t = *mean / se;
    let d = *mean / sd;

    // Some((state.0, new_mean, squared_distances, sd, se, d, t))

    Some((*group, *count, *mean, *squared_distances, sd, se, d, t))
}

fn one_sample_t(t: f64, n: i32, _tail: i16) -> f64 {
    2f64 * students_t_cdf(t, (n - 1) as f64, false, false)
}

fn bf_onesample_default_t(d: f64, n: i32, prior: &Prior) -> Option<f64> {
    // let d = mean / sd;
    let likelihood = noncentral_d_likelihood(d, n as f64);

    let h1_prior = prior.function();
    let null = likelihood(0.0);
    let h1 = create_predictive(likelihood, h1_prior);
    let alt = Integrator::new(h1)
        .algorithm(QAGS::new())
        .run(NEG_INFINITY..INFINITY)
        .estimate()
        .unwrap();
    Some((alt / null).ln())
}

#[pyfunction]
fn sim_withrandom(
    random_values: Vec<f64>,
    prior: Prior,
    effsize: f64,
    sampling_rule: SamplingRule,
) -> Vec<(usize, f64, f64, Option<f64>, f64, f64, f64)> {
    let (n_min, n_max, step_size) = sampling_rule.unpack();

    random_values
        .into_par_iter()
        .chunks(n_max as usize)
        .enumerate()
        .map(|(i, group)| {
            group
                .iter()
                .scan((i, 0., 0., 0., 0., 0., 0., 0.), welfords)
                .collect_vec()
        })
        .flatten()
        .filter(|(_, n, _, _, _, _, _, _)| (*n as i32 >= n_min) && (*n as i32 % step_size) == 0)
        .map(|(id, n, _, _, _, _, d, t)| {
            let bf = if n < 2. {
                None
            } else {
                bf_onesample_default_t(d, n as i32, &prior)
            };

            let pvalue = one_sample_t(t, n as i32, 0);
            (id, effsize, n, bf, d, t, pvalue)
        })
        .collect()
}

#[pymodule]
fn pyby(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(sim_withrandom, m)?)?;
    Ok(())
}

fn noncentral_d_likelihood(d: f64, n: f64) -> impl Fn(f64) -> f64 {
    move |x: f64| dt(d * n.sqrt(), n - 1., n.sqrt() * x)
}

fn cauchy_auc(location: f64, scale: f64, ll: Option<f64>, ul: Option<f64>) -> f64 {
    match (ll, ul) {
        (None, None) => 1.,
        (Some(_), None) => pcauchy(ll.unwrap(), location, scale, false, false),
        (None, Some(_)) => pcauchy(ul.unwrap(), location, scale, true, false),
        (Some(_), Some(_)) => {
            1.0 - ((1.0 - pcauchy(ll.unwrap(), location, scale, false, false))
                + (1.0 - pcauchy(ul.unwrap(), location, scale, true, false)))
        }
    }
}

fn cauchy_prior(
    location: f64,
    scale: f64,
    ll: Option<f64>,
    ul: Option<f64>,
) -> Box<impl Fn(f64) -> f64> {
    let k = 1.0 / cauchy_auc(location, scale, ll, ul);
    Box::new(move |x: f64| dcauchy(x, location, scale, false) * k)
}

fn dt(x: f64, df: f64, ncp: f64) -> f64 {
    non_central_t_pdf(x, df, ncp, false)
}

fn create_predictive(
    likelihood: impl Fn(f64) -> f64,
    prior: impl Fn(f64) -> f64,
) -> impl Fn(f64) -> f64 {
    move |x: f64| likelihood(x) * prior(x)
}

#[cfg(test)]
mod tests {

    use super::*;
    use float_cmp::approx_eq;

    const TOL: f64 = 0.00001;

    #[test]
    fn test0() {
        let got = 1.0;
        let want = 1.0;
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );
    }

    #[test]
    fn test1() {
        let prior = Prior {
            family: "Cauchy".to_string(),
            params: vec![0., (2f64).sqrt() / 2.0],
            alternative: "two.sided".to_string(),
        };
        let got =
            bf_onesample_default_t(0.508114037354055 / 1.06850369859537, 140, &prior).unwrap();
        let want = 113_731.668_902_044_87_f64.ln();
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );
    }

    #[test]
    fn test2() {
        let prior = Prior {
            family: "Cauchy".to_string(),
            params: vec![0., (2f64).sqrt() / 2.0],
            alternative: "two.sided".to_string(),
        };
        let want = 304_475.155_827_261_7_f64.ln();
        let got =
            bf_onesample_default_t(0.508114037354055 / 1.06850369859537, 150, &prior).unwrap();
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );
    }

    #[test]
    fn test3() {
        let got = dt(0.1, 10., 2.);
        let want = 0.06434707;

        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );
    }

    #[test]
    fn cauchy_area() {
        let want = 1.;
        let got = cauchy_auc(0., 1., None, None);

        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );

        let want = 0.5;
        let got = cauchy_auc(0., 1., Some(0.), None);
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );

        let want = 0.3788811;
        let got = cauchy_auc(0., 1., Some(0.4), None);
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );

        let want = 0.6211189;
        let got = cauchy_auc(0., 1., Some(-0.4), None);
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );

        let want = 0.3361116;
        let got = cauchy_auc(0., 0.707, None, Some(-0.4));
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );

        let want = 0.3277769;
        let got = cauchy_auc(0.0, 0.707, Some(-0.4), Some(0.4));
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );
        let want = 0.07613601;
        let got = cauchy_auc(0.0, 0.707, Some(0.2), Some(0.4));
        assert!(
            approx_eq!(f64, got, want, epsilon = TOL),
            "got = {}; want = {}",
            got,
            want
        );
    }
}

